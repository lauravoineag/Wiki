## Becoming a great Software Engineer 

**1. Rough and then refined** 
`Shift your thinking from finding the perfect solution to that off adding value to your team. That means solving the problem in the time limits you have, making sure that your code style fits in with the wider codebase, and that it is tested and works properly.`
`Understanding when a solution is` ["good enough"](https://en.wikipedia.org/wiki/MoSCoW_method)

**2. Solve the problem in your head and then write the code**
`There is a difference between solving a problem and writing code to implement a solution for that problem.`
`Writing an executable program in code to implement your solution is a separate exercise and a different challenge to actually figuring out the solution in the first place.`

`Now primarily focus on the challenge of writing executable/maintainable/clear code that implements the logic instead of conflating the two challenges which makes it hard to focus on either one.`

`Another benefit of this technique is that by the time you reach the third step you would have articulated the problem in several different formats. Your brain has thought about a problem from different angles and in different ways. This means any glaring logic bugs have usually presented themselves and been fixed in an early part of the process which is much cheaper to fix. For example, you can move sticky notes about more quickly than you can move code around in an IDE.`

`A final benefit is the massively increased understanding that comes from the journey. This makes it easier to talk about your program in the future, easier to remember when you are am trying to fix it in production & wasier to write documentation for the team. This makes you a much more valuable member of the team.`
   
  ***How to do it:***
| ***First*** | ***Second*** | ***Third*** |
| ------------| -------------|-------------|
| `Actually solve the logical problem by working it out on paper and sticky notes.For example, use sticky notes to represent ‘if’ statements and then the subsequent branches in logic which I can then physically move about.`  | `Write clear comments in code which give an overview of what the code is going to be. This is the skeleton of the program.` | `Now you are ready to type the code. By this point you properly understand the solution to the problem and it has been through several iterations.` |

**3. No-one knows everything**
`Every developer has their own weaknesses, the industry is so vast and ever-changing.  Instead, work out what is important to you … and learn it!`
<figure>
    <img src="/Dependency-injection.PNG"
         alt="Dependency-injection">
    <figcaption></figcaption>
</figure>

**4. Open and Honest about shortcomings** 
`Any developer should be happy to explain something to you if you admit you don’t know it. If they make you feel embarrassed for asking a question, then it is their issue that they need to work on and not your perceived ignorance for asking a question.`
    
**5. You are responsible for your own learning path**
`People will help but you need to lead the way.`

**6. You do not really understand something unless you explain it to your grandmother**

`There is a difference between understanding how to use something and how/why something works. Focus on learning the latter. In the same time don't waste your time trying to figure out the details of how nuget package x, module y, etc works. Learn the classes which it exposes you to and how to use them affectively. Some people want to look under the hood to get new ideas on how to do things better.`

`There is a big difference between understanding how complicated things work in your head and being able to explain how they work to others.`

**7. The best software engineers think like designers**
`Great software engineers think deeply about the user experience of their code. They might not think about it in those terms, but whether it is an external API, programmatic API, user interface, protocol, or any other interface; great engineers consider who will be using it, why it will be used, how it will be used, and what is important to those users. Keeping the user’s needs in mind is really the heart of good user experience.`

**8. The best code is no code, or code you don’t have to maintain**
`“Coders will code.” You ask someone in any profession how to solve a problem, and they are going to err on the side of what they are good at. It is just human nature. Most software engineers are always going to err on the side of writing code, especially when a non-technical solution isn’t obvious. The same goes for code you don’t have to maintain. Engineering teams are apt to want to reinvent the wheel, when lots of wheels already exist. This is a balancing act, there are lots of reasons to grow your own, but beware of toxic “Not Invented Here” syndrome.`

**9. Software is a means to an end**
`The primary job of any software engineer is delivering value. Very few software developers understand this, even fewer internalize it. Truly internalizing this leads to a different way of solving problems, and a different way of viewing your tools. If you really believe that software is subservient to the outcome, you’ll be ready to really find “the right tool for the job” which might not be software at all.`

**10. Sometimes you have to stop sharpening the saw, and just start cutting**
`Some people tend to jump into problems and just start writing code. Other people tend to want to research and research and get caught in analysis paralysis. So, set a deadline and just start exploring. You’ll quickly learn more as you start solving problems, and that will lead you to iterate into a better solution.`

**11. If you don’t have a good grasp of the universe of what’s possible, you can’t design a good system**
`Keeping up with the developer ecosystem is a huge amount of work, but it is critical to understand what is possible. If you don’t understand what is possible and what is available in a given ecosystem then you’ll find it impossible to design a reasonable solution to all but the most simple of problems. To summarize, be wary of people designing systems who haven’t written any code in a long time.`

**12. Every system will eventually be outdated, get over it**
`Bjarne Stroustrup has a quote that goes “There are only two kinds of languages: the ones people complain about and the ones nobody uses”. This can be extended to large systems as well. There is no “right” architecture, you’ll never pay down all of your technical debt, you’ll never design the perfect interface, your tests will always be too slow. This isn’t an excuse to never make things better, but instead a way to give you perspective. Worry less about elegance and perfection; instead strive for continuous improvement and creating a livable system that your team enjoys working in and sustainably delivers value.`

**13. We should be far more focused on avoiding 0.1x programmers than finding 10x programmers**
`The 10x programmer is a silly myth. The idea that someone can produce in 1 day what another competent, hard working, similarly experienced programmer can produce in 2 weeks is silly. The only way someone can be a 10x programmer is if you compare them to 0.1x programmers. Someone who wastes time, doesn’t ask for feedback, doesn’t test their code, doesn’t consider edge cases, etc… We should be far more concerned with keeping 0.1x programmers off our teams than finding the mythical 10x programmer.`

**14. One of the biggest differences between a senior engineer and a junior engineer is that they’ve formed opinions about the way things should be**
`Nothing worries more than a senior engineer that has no opinion of their tools or how to approach building software. I’d rather someone give me opinions that I violently disagree with than for them to have no opinions at all. If you are using your tools, and you don’t love or hate them in a myriad of ways, you need to experience more. You need to explore other languages, libraries, and paradigms. There are few ways of leveling up your skills faster than actively seeking out how others accomplish tasks with different tools and techniques than you do.`

**15.  People don’t really want innovation**
`People talk about innovation a whole lot, but what they are usually looking for is cheap wins and novelty. If you truly innovate, and change the way that people have to do things, expect mostly negative feedback. If you believe in what you’re doing, and know it will really improve things, then brace yourself for a long battle.`

**16. Your data is the most important part of your system**
`Your data will likely long outlive your codebase. Spend energy keeping it orderly and clean.`

**17.  Look for technological sharks**
`Old technologies that have stuck around are sharks, not dinosaurs. They solve problems so well that they have survived the rapid changes that occur constantly in the technology world. Don’t bet against these technologies, and replace them only if you have a very good reason. These tools won’t be flashy, and they won’t be exciting, but they will get the job done without a lot of sleepless nights.`

**18. Don’t mistake humility for ignorance**
`There are a lot of software engineers out there who won’t express opinions unless asked. Never assume that just because someone isn’t throwing their opinions in your face that they don’t have anything to add. Sometimes the noisiest people are the ones we want to listen to the least. Talk to the people around you, seek their feedback and advice. You’ll be glad you did.`

**19. Software engineers should write regularly** 
`Software engineers should regularly blog, journal, write documentation and in general do anything that requires them to keep their written communication skills sharp. Writing helps you think about your problems, and helps you communicate those more effectively with your team and your future self. Good written communication is one of the most important skills for any software engineer to master.`

**20. Keep your processes as lean as possible**
`Everyone wants to be agile these days, but being “agile” is about building things in small chunks, learning, and then iterating. It isn’t to say that people don’t need accountability or help to work this way, but how many times have you heard someone from your favorite tech company or large open source project brag about how great their Scrum process is? Stay lean on process until you know you need more. Trust your team and they will deliver.`

**21. Software engineers, like all humans, need to feel ownership**
`If you divorce someone from the output of their work, they will care less about their work. This is the primary reason why cross-functional teams work so well, and why DevOps has become so popular. It isn’t all about handoffs and inefficiencies, it is about owning the whole process from start to finish, and being directly responsible for delivering value. Give a group of passionate people complete ownership over designing, building, and delivering a piece of software (or anything really) and amazing things will happen.`

**22.  Interviews won't give a good indication in determining if someone is a good team player**
`Interviews are far better spent trying to understand who someone is, and how interested they are in a given field of expertise. How smart or knowledgable someone is does not give an idication if they will be a great team member. No one is going to tell you in an interview that they are going to be unreliable, abusive, pompous, or never show up to meetings on time. People might claim they have “signals” for these things… “if they ask about time off in the first interview then they are never going to be there!”. If you’re using signals like these you’re just guessing and turning away good candidates.`

**23.  Always strive to build a smaller system**
`There are a lot of forces that will push you to build the bigger system up-front. Budget allocation, the inability to decide which features should be cut, the desire to deliver the “best version” of a system. All of these things push us very forcefully towards building too much. You should fight this. You learn so much as you’re building a system that you will end up iterating into a much better system than you ever could have designed in the first place. This is surprisingly a hard sell to most people.`

**Articles and Inspiration**
[Lessons I’ve learned from 2.5 years of Software Engineering](https://www.freecodecamp.org/news/lessons-from-2-5-years-of-software-engineering-da66891f1b09/)
[Coding Interview University](https://github.com/jwasham/coding-interview-university)
[20 Things I’ve Learned in my 20 Years as a Software Engineer](https://www.simplethread.com/20-things-ive-learned-in-my-20-years-as-a-software-engineer/)
[Clean Arhitecture](https://github.com/jasontaylordev/CleanArchitecture)
[Markdown](https://www.markdownguide.org/basic-syntax/)